name: GCP GKE CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      CLUSTER_NAME: moon-insurance-cluster
      CLUSTER_ZONE: us-central1-c

    steps:
      # Step 1: Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Authenticate to Google Cloud
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      # Step 3: Set up Google Cloud SDK
      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      # Step 4: Configure Docker to use gcloud as a credential helper
      - name: Configure Docker for GCR
        run: |
          gcloud auth configure-docker

      # Step 5: Build and push Docker images to GCR
      - name: Build and Push Docker Images
        run: |
          SERVICES=("agent-service" "integration-service" "notification-service" "aggregator-service" "redshift-analytics-service")
          for SERVICE in "${SERVICES[@]}"; do
            echo "Building image for $SERVICE..."
            docker build -t gcr.io/${PROJECT_ID}/${SERVICE}:latest -f ./${SERVICE}/docker/Dockerfile ./${SERVICE}
            echo "Pushing image for $SERVICE..."
            docker push gcr.io/${PROJECT_ID}/${SERVICE}:latest
          done

      # Step 6: Get GKE cluster credentials
      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials $CLUSTER_NAME --zone $CLUSTER_ZONE --project $PROJECT_ID

      # Step 7: Deploy Kubernetes manifests
      - name: Deploy to GKE
        env:
          MONGO_URI: ${{ secrets.MONGO_URI }}
          REDSHIFT_HOST: ${{ secrets.REDSHIFT_HOST }}
          REDSHIFT_PORT: ${{ secrets.REDSHIFT_PORT }}
          REDSHIFT_USER: ${{ secrets.REDSHIFT_USER }}
          REDSHIFT_PASSWORD: ${{ secrets.REDSHIFT_PASSWORD }}
          REDSHIFT_DBNAME: ${{ secrets.REDSHIFT_DBNAME }}
        run: |
          kubectl apply -f ./agent-service/manifests/
          kubectl apply -f ./integration-service/manifests/
          kubectl apply -f ./notification-service/manifests/
          kubectl apply -f ./aggregator-service/manifests/
          kubectl apply -f ./redshift-analytics-service/manifests/
          kubectl apply -f ./ingress.yaml

      # Step 8: Wait for services to be ready
      - name: Wait for Kubernetes resources to be ready
        run: |
          kubectl wait --for=condition=available --timeout=600s deployment/agent-service
          kubectl wait --for=condition=available --timeout=600s deployment/integration-service
          kubectl wait --for=condition=available --timeout=600s deployment/notification-service
          kubectl wait --for=condition=available --timeout=600s deployment/aggregator-service

      # Step 9: Trigger Redshift Analytics CronJob manually
      - name: Trigger Redshift CronJob manually
        run: |
          kubectl create job --from=cronjob/redshift-analytics-cronjob redshift-analytics-manual || echo "CronJob not found, skipping."

      # Step 10: Post-deploy verification
      - name: Verify Deployments
        run: |
          kubectl get pods -A
          kubectl get services -A
          kubectl get ingress -A

      # Step 11: Fetch GKE LoadBalancer IP and print
      - name: Get GKE Ingress External IP
        run: |
          echo "Fetching external IP for ingress..."
          for i in {1..30}; do
            INGRESS_IP=$(kubectl get ingress mooninsurance-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [[ -n "$INGRESS_IP" ]]; then
              echo "Ingress IP: $INGRESS_IP"
              echo "::set-output name=ingress_ip::$INGRESS_IP"
              break
            fi
            echo "Waiting for ingress IP allocation... ($i/30)"
            sleep 10
          done

          